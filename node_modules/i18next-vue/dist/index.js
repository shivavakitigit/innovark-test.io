"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// index.ts
var i18next_vue_exports = {};
__export(i18next_vue_exports, {
  TranslationComponent: () => TranslationComponent,
  default: () => install,
  useTranslation: () => useTranslation
});
module.exports = __toCommonJS(i18next_vue_exports);
var import_vue = require("vue");
function install(app, {
  i18next,
  rerenderOn = ["languageChanged", "loaded", "added", "removed"]
}) {
  const genericT = i18next.t.bind(i18next);
  const lastI18nChange = (0, import_vue.ref)(new Date());
  const invalidate = () => lastI18nChange.value = new Date();
  const usingI18n = () => lastI18nChange.value;
  rerenderOn.forEach((event) => {
    var _a;
    switch (event) {
      case "added":
      case "removed":
        (_a = i18next.store) == null ? void 0 : _a.on(event, invalidate);
        break;
      default:
        i18next.on(event, invalidate);
        break;
    }
  });
  app.component("i18next", TranslationComponent);
  app.mixin({
    beforeCreate() {
      var _a, _b;
      const options = this.$options;
      if (!options.__i18n && !options.i18nOptions) {
        this.__translate = void 0;
        return;
      }
      const name = this.$options.name;
      const rand = (Math.random() * 10 ** 8 | 0).toString();
      const localNs = [name, rand].filter((x) => !!x).join("-");
      this.__bundles = [];
      const loadBundle = (bundle) => {
        Object.entries(bundle).forEach(([lng2, resources]) => {
          i18next.addResourceBundle(lng2, localNs, resources, true, false);
          this.__bundles.push([lng2, localNs]);
        });
      };
      (_a = options.__i18n) == null ? void 0 : _a.forEach((bundle) => {
        loadBundle(JSON.parse(bundle));
      });
      let { lng, ns, keyPrefix } = handleI18nOptions(options, loadBundle);
      if ((_b = this.__bundles) == null ? void 0 : _b.length) {
        ns = [localNs].concat(ns != null ? ns : []);
      }
      const t = getTranslationFunction(lng, ns);
      this.__translate = (key, options2) => {
        if (!keyPrefix || includesNs(key)) {
          return t(key, options2);
        } else {
          return t(keyPrefix + "." + key, options2);
        }
      };
    },
    unmounted() {
      var _a;
      (_a = this.__bundles) == null ? void 0 : _a.forEach(([lng, ns]) => i18next.removeResourceBundle(lng, ns));
    }
  });
  app.config.globalProperties.$t = function(key, options) {
    var _a;
    usingI18n();
    if (i18next.isInitialized) {
      return ((_a = this == null ? void 0 : this.__translate) != null ? _a : genericT)(key, options);
    } else {
      return key;
    }
  };
  app.config.globalProperties.$i18next = new Proxy(i18next, {
    get(target, prop) {
      usingI18n();
      return Reflect.get(target, prop);
    }
  });
  function getTranslationFunction(lng, ns) {
    if (lng) {
      return i18next.getFixedT(lng, ns);
    } else if (ns) {
      return i18next.getFixedT(null, ns);
    } else {
      return genericT;
    }
  }
  function includesNs(key) {
    const nsSeparator = i18next.options.nsSeparator;
    return typeof nsSeparator === "string" && key.includes(nsSeparator);
  }
  function handleI18nOptions(options, loadBundle) {
    let lng;
    let ns;
    let keyPrefix;
    if (options.i18nOptions) {
      let messages;
      let namespaces;
      ({
        lng,
        namespaces = i18next.options.defaultNS,
        keyPrefix,
        messages
      } = options.i18nOptions);
      if (messages) {
        loadBundle(messages);
      }
      ns = typeof namespaces === "string" ? [namespaces] : namespaces;
      if (ns) {
        i18next.loadNamespaces(ns);
      }
    }
    return { lng, ns, keyPrefix };
  }
}
function useTranslation() {
  const instance = (0, import_vue.getCurrentInstance)();
  if (!instance) {
    throw new Error("i18next-vue: No Vue instance in context. Make sure to register the i18next-vue plugin using app.use(...).");
  }
  const globalProps = instance.appContext.config.globalProperties;
  return {
    i18next: globalProps.$i18next,
    t: globalProps.$t.bind(instance.proxy)
  };
}
var slotNamePattern = new RegExp("{\\s*([a-z0-9\\-]+)\\s*}", "gi");
var TranslationComponent = (0, import_vue.defineComponent)({
  props: {
    "translation": {
      type: String,
      required: true
    }
  },
  setup(props, { slots }) {
    return () => {
      const translation = props.translation;
      const result = [];
      let match;
      let lastIndex = 0;
      while ((match = slotNamePattern.exec(translation)) !== null) {
        result.push(translation.substring(lastIndex, match.index));
        const slot = slots[match[1]];
        if (slot) {
          result.push(...slot());
        } else {
          result.push(match[0]);
        }
        lastIndex = slotNamePattern.lastIndex;
      }
      result.push(translation.substring(lastIndex));
      return result;
    };
  }
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  TranslationComponent,
  useTranslation
});
